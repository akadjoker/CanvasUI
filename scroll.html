<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Widgets OOP em JavaScript Puro</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid #ddd;
            background-color: white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <h1>Widgets em JavaScript Orientado a Objetos</h1>
    
    <script>
    // Classe base para todos os widgets
    class Widget {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      
      // Métodos a serem sobrescritos pelas classes filhas
      draw(ctx) {}
      handleMouseMove(x, y) {}
      handleMouseDown(x, y) {}
      handleMouseUp(x, y) {}
      handleWheel(deltaY) {}
      
      // Verifica se o ponto está dentro do widget
      isPointInside(x, y) {
        return x >= this.x && x <= this.x + this.width && 
               y >= this.y && y <= this.y + this.height;
      }
    }

    // Classe para o botão
    class Button extends Widget {
      constructor(x, y, width, height, text, onClick) {
        super(x, y, width, height);
        this.text = text;
        this.onClick = onClick;
        this.isHovered = false;
        this.isPressed = false;
      }
      
      draw(ctx) {
        // Fundo do botão
        ctx.fillStyle = this.isPressed ? '#2980b9' : this.isHovered ? '#3498db' : '#2ecc71';
        ctx.beginPath();
        ctx.roundRect(this.x, this.y, this.width, this.height, 8);
        ctx.fill();
        
        // Efeito de sombra
        if (!this.isPressed) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.beginPath();
          ctx.roundRect(this.x, this.y + 3, this.width, this.height, 8);
          ctx.fill();
        }
        
        // Texto do botão
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(
          this.text, 
          this.x + this.width / 2, 
          this.y + this.height / 2 + (this.isPressed ? 1 : 0)
        );
      }
      
      handleMouseMove(x, y) {
        this.isHovered = this.isPointInside(x, y);
        return this.isHovered;
      }
      
      handleMouseDown(x, y) {
        if (this.isPointInside(x, y)) {
          this.isPressed = true;
          return true;
        }
        return false;
      }
      
      handleMouseUp(x, y) {
        if (this.isPressed && this.isPointInside(x, y)) {
          this.onClick();
        }
        this.isPressed = false;
        return this.isPointInside(x, y);
      }
    }

    // Classe para ScrollView
    class ScrollView extends Widget {
      constructor(x, y, width, height, content) {
        super(x, y, width, height);
        this.content = content;
        this.scrollPosition = 0;
        this.maxScroll = 0;
        this.isDraggingScroll = false;
        this.scrollBarWidth = 15;
        this.lineHeight = 20;
      }
      
      draw(ctx) {
        // Fundo
        ctx.fillStyle = '#ecf0f1';
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Área de conteúdo
        ctx.save();
        ctx.beginPath();
        ctx.rect(this.x, this.y, this.width, this.height);
        ctx.clip();
        
        // Renderizar texto
        this._renderContent(ctx);
        
        ctx.restore();
        
        // Barra de rolagem
        this._drawScrollBar(ctx);
      }
      
      _renderContent(ctx) {
        ctx.fillStyle = '#34495e';
        ctx.font = '14px Arial';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        
        const maxWidth = this.width - this.scrollBarWidth - 10;
        const words = this.content.split(' ');
        
        let line = '';
        let y = this.y + 10 - this.scrollPosition;
        
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + ' ';
          const metrics = ctx.measureText(testLine);
          
          if (metrics.width > maxWidth && i > 0) {
            ctx.fillText(line, this.x + 10, y);
            line = words[i] + ' ';
            y += this.lineHeight;
          } else {
            line = testLine;
          }
        }
        
        ctx.fillText(line, this.x + 10, y);
        
        // Calcular altura total do conteúdo
        const contentHeight = y + this.lineHeight - this.y + this.scrollPosition;
        this.maxScroll = Math.max(0, contentHeight - this.height + 20);
      }
      
      _drawScrollBar(ctx) {
        if (this.maxScroll > 0) {
          const contentHeight = this.scrollPosition + this.height + this.maxScroll;
          const scrollHeight = Math.max(30, this.height * (this.height / contentHeight));
          const scrollPosition = (this.scrollPosition / this.maxScroll) * (this.height - scrollHeight);
          
          // Trilho da barra de rolagem
          ctx.fillStyle = '#bdc3c7';
          ctx.fillRect(this.x + this.width - this.scrollBarWidth, this.y, this.scrollBarWidth, this.height);
          
          // Barra de rolagem
          ctx.fillStyle = this.isDraggingScroll ? '#7f8c8d' : '#95a5a6';
          ctx.fillRect(
            this.x + this.width - this.scrollBarWidth + 2, 
            this.y + scrollPosition, 
            this.scrollBarWidth - 4, 
            scrollHeight
          );
        }
      }
      
      _isPointInScrollBar(x, y) {
        return x >= this.x + this.width - this.scrollBarWidth && 
               x <= this.x + this.width && 
               y >= this.y && 
               y <= this.y + this.height;
      }
      
      handleMouseMove(x, y) {
        if (this.isDraggingScroll) {
          const scrollableHeight = this.height - (this.height * (this.height / (this.maxScroll + this.height)));
          const scrollRatio = (y - this.y) / this.height;
          this.scrollPosition = Math.max(0, Math.min(this.maxScroll, this.maxScroll * scrollRatio));
          return true;
        }
        return this.isPointInside(x, y);
      }
      
      handleMouseDown(x, y) {
        if (this._isPointInScrollBar(x, y)) {
          this.isDraggingScroll = true;
          return true;
        }
        return this.isPointInside(x, y);
      }
      
      handleMouseUp(x, y) {
        this.isDraggingScroll = false;
        return this.isPointInside(x, y);
      }
      
      handleWheel(deltaY) {
        if (this.isPointInside(this.lastMouseX, this.lastMouseY)) {
          this.scrollPosition += deltaY * 0.5;
          this.scrollPosition = Math.max(0, Math.min(this.maxScroll, this.scrollPosition));
          return true;
        }
        return false;
      }
    }

    // Classe para Knob circular
    class Knob extends Widget {
      constructor(x, y, radius, onChange) {
        super(x - radius, y - radius, radius * 2, radius * 2);
        this.centerX = x;
        this.centerY = y;
        this.radius = radius;
        this.value = 0.5; // 0 to 1
        this.isDragging = false;
        this.startAngle = -0.75 * Math.PI;
        this.endAngle = 0.75 * Math.PI;
        this.onChange = onChange || function() {};
      }
      
      draw(ctx) {
        // Fundo do knob
        ctx.fillStyle = '#ecf0f1';
        ctx.beginPath();
        ctx.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Borda
        ctx.strokeStyle = '#bdc3c7';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Trilho
        ctx.strokeStyle = '#95a5a6';
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.arc(this.centerX, this.centerY, this.radius - 15, this.startAngle, this.endAngle);
        ctx.stroke();
        
        // Valor atual
        const valueAngle = this.startAngle + (this.endAngle - this.startAngle) * this.value;
        ctx.strokeStyle = '#3498db';
        ctx.beginPath();
        ctx.arc(this.centerX, this.centerY, this.radius - 15, this.startAngle, valueAngle);
        ctx.stroke();
        
        // Marcador
        ctx.fillStyle = '#2c3e50';
        ctx.beginPath();
        const markerX = this.centerX + Math.cos(valueAngle) * (this.radius - 15);
        const markerY = this.centerY + Math.sin(valueAngle) * (this.radius - 15);
        ctx.arc(markerX, markerY, 8, 0, Math.PI * 2);
        ctx.fill();
        
        // Valor como texto
        ctx.fillStyle = '#2c3e50';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(Math.round(this.value * 100) + '%', this.centerX, this.centerY);
      }
      
      isPointInside(x, y) {
        const dx = x - this.centerX;
        const dy = y - this.centerY;
        return Math.sqrt(dx * dx + dy * dy) <= this.radius;
      }
      
      _calculateValue(x, y) {
        const dx = x - this.centerX;
        const dy = y - this.centerY;
        let angle = Math.atan2(dy, dx);
        
        // Ajustar para o intervalo de ângulos do knob
        if (angle < this.startAngle) {
          angle += Math.PI * 2;
        }
        
        // Limitar o ângulo ao intervalo válido
        angle = Math.max(this.startAngle, Math.min(this.endAngle, angle));
        
        // Mapear o ângulo para um valor entre 0 e 1
        return (angle - this.startAngle) / (this.endAngle - this.startAngle);
      }
      
      handleMouseMove(x, y) {
        if (this.isDragging) {
          const oldValue = this.value;
          this.value = this._calculateValue(x, y);
          
          if (oldValue !== this.value) {
            this.onChange(this.value);
          }
          return true;
        }
        return this.isPointInside(x, y);
      }
      
      handleMouseDown(x, y) {
        if (this.isPointInside(x, y)) {
          this.isDragging = true;
          return true;
        }
        return false;
      }
      
      handleMouseUp(x, y) {
        this.isDragging = false;
        return this.isPointInside(x, y);
      }
    }
    class App {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.widgets = [];
        this.mouseX = 0;
        this.mouseY = 0;
        
        // Configurar event listeners
        this._setupEventListeners();
      }
      
      _setupEventListeners() {
        this.canvas.addEventListener('mousemove', this._handleMouseMove.bind(this));
        this.canvas.addEventListener('mousedown', this._handleMouseDown.bind(this));
        this.canvas.addEventListener('mouseup', this._handleMouseUp.bind(this));
        this.canvas.addEventListener('wheel', this._handleWheel.bind(this));
      }
      
      _handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mouseX = e.clientX - rect.left;
        this.mouseY = e.clientY - rect.top;
        
        for (const widget of this.widgets) {
          widget.lastMouseX = this.mouseX;
          widget.lastMouseY = this.mouseY;
          widget.handleMouseMove(this.mouseX, this.mouseY);
        }
      }
      
      _handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        for (const widget of this.widgets) {
          widget.handleMouseDown(x, y);
        }
      }
      
      _handleMouseUp(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        for (const widget of this.widgets) {
          widget.handleMouseUp(x, y);
        }
      }
      
      _handleWheel(e) {
        e.preventDefault();
        
        for (const widget of this.widgets) {
          if (widget.handleWheel(e.deltaY)) {
            break;
          }
        }
      }
      
      addWidget(widget) {
        this.widgets.push(widget);
        return widget;
      }
      
      removeWidget(widget) {
        const index = this.widgets.indexOf(widget);
        if (index !== -1) {
          this.widgets.splice(index, 1);
        }
      }
      
      render() {
        // Limpar canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Desenhar títulos
        this.ctx.fillStyle = '#2c3e50';
        this.ctx.font = 'bold 18px Arial';
        this.ctx.textAlign = 'left';
        this.ctx.textBaseline = 'top';
        this.ctx.fillText("Botão em JavaScript Orientado a Objetos", 50, 20);
        this.ctx.fillText("ScrollView em JavaScript Orientado a Objetos", 50, 120);
        this.ctx.fillText("Knob Circular em JavaScript Orientado a Objetos", 450, 120);
        
        // Desenhar widgets
        for (const widget of this.widgets) {
          widget.draw(this.ctx);
        }
        
        // Continuar animação
        requestAnimationFrame(this.render.bind(this));
      }
      
      start() {
        this.render();
      }
    }

    // Inicializar quando a página carregar
    window.onload = function() {
      const canvas = document.createElement('canvas');
      canvas.width = 800;
      canvas.height = 600;
      document.body.appendChild(canvas);
      
      const app = new App(canvas);
      
      // Adicionar botão
      app.addWidget(new Button(50, 50, 150, 50, "Clique Aqui", function() {
        console.log("Botão clicado!");
        alert("Botão clicado!");
      }));
      
      // Adicionar ScrollView
      const loremIpsum = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.";
      app.addWidget(new ScrollView(50, 150, 300, 200, loremIpsum));
      
      // Adicionar Knob
      app.addWidget(new Knob(550, 200, 80, function(value) {
        console.log("Valor do knob:", value);
      }));
      
      // Iniciar a renderização
      app.start();
    };
    </script>
</body>
</html>