<!DOCTYPE html>
<html>
<head>
    <title>Sistema de Layout em Canvas</title>
</head>
<body>
    <canvas id="layoutCanvas"></canvas>
    <script>

// Canvas Layout System
class LayoutController {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.layouts = [];
    this.width = canvas.width;
    this.height = canvas.height;
  }

  addLayout(layout) {
    this.layouts.push(layout);
    this.recalculateSizes();
    return layout;
  }

  recalculateSizes() {
    // Primeiro passo: calcular espaço disponível e necessário
    const totalSpace = { width: this.width, height: this.height };
    let remainingSpace = { ...totalSpace };
    
    // Calcular layouts com tamanhos fixos primeiro
    this.layouts.forEach(layout => {
      if (layout.fixedSize) {
        if (layout.direction === 'horizontal') {
          remainingSpace.width -= layout.fixedSize;
        } else {
          remainingSpace.height -= layout.fixedSize;
        }
      }
    });

    // Distribuir espaço restante com base nas porcentagens
    this.layouts.forEach(layout => {
      if (!layout.fixedSize) {
        if (layout.direction === 'horizontal') {
          layout.actualSize = Math.floor(remainingSpace.width * (layout.percentage / 100));
        } else {
          layout.actualSize = Math.floor(remainingSpace.height * (layout.percentage / 100));
        }
      } else {
        layout.actualSize = layout.fixedSize;
      }
    });

    // Posicionar os layouts
    let currentX = 0;
    let currentY = 0;
    
    this.layouts.forEach(layout => {
      layout.x = currentX;
      layout.y = currentY;
      
      if (layout.direction === 'horizontal') {
        currentX += layout.actualSize;
      } else {
        currentY += layout.actualSize;
      }
    });
  }

  render() {
    // Limpar canvas
    this.ctx.clearRect(0, 0, this.width, this.height);
    
    // Renderizar cada layout
    this.layouts.forEach(layout => {
      layout.render(this.ctx);
    });
  }
}

class Layout {
  constructor(options = {}) {
    this.direction = options.direction || 'horizontal'; // horizontal ou vertical
    this.percentage = options.percentage || 100; // porcentagem do espaço disponível
    this.fixedSize = options.fixedSize || null; // tamanho fixo (se definido)
    this.color = options.color || '#f0f0f0';
    this.widgets = [];
    
    // Será definido pelo controlador de layout
    this.x = 0;
    this.y = 0;
    this.actualSize = 0;
  }

  addWidget(widget) {
    this.widgets.push(widget);
    return widget;
  }

  render(ctx) {
    // Desenhar fundo do layout
    ctx.fillStyle = this.color;
    
    if (this.direction === 'horizontal') {
      ctx.fillRect(this.x, this.y, this.actualSize, ctx.canvas.height - this.y);
    } else {
      ctx.fillRect(this.x, this.y, ctx.canvas.width - this.x, this.actualSize);
    }
    
    // Renderizar widgets
    this.widgets.forEach(widget => {
      widget.x += this.x;
      widget.y += this.y;
      widget.render(ctx);
      widget.x -= this.x;
      widget.y -= this.y;
    });
  }
}

class Widget {
  constructor(options = {}) {
    this.x = options.x || 0;
    this.y = options.y || 0;
    this.width = options.width || 100;
    this.height = options.height || 40;
    this.text = options.text || '';
    this.color = options.color || '#3498db';
    this.textColor = options.textColor || '#ffffff';
  }

  render(ctx) {
    // Desenhar fundo do widget
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    
    // Desenhar texto
    ctx.fillStyle = this.textColor;
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);
  }
}

class Button extends Widget {
  constructor(options = {}) {
    super(options);
    this.hovered = false;
    this.onClick = options.onClick || (() => {});
  }

  isPointInside(x, y) {
    return x >= this.x && x <= this.x + this.width && 
           y >= this.y && y <= this.y + this.height;
  }

  render(ctx) {
    // Desenhar fundo do botão (mais escuro se hover)
    ctx.fillStyle = this.hovered ? this.darkenColor(this.color) : this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    
    // Adicionar borda
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = 2;
    ctx.strokeRect(this.x, this.y, this.width, this.height);
    
    // Desenhar texto
    ctx.fillStyle = this.textColor;
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);
  }
  
  darkenColor(color) {
    // Função simples para escurecer uma cor para efeito hover
    const r = parseInt(color.substr(1, 2), 16) - 20;
    const g = parseInt(color.substr(3, 2), 16) - 20;
    const b = parseInt(color.substr(5, 2), 16) - 20;
    return `#${Math.max(0, r).toString(16).padStart(2, '0')}${Math.max(0, g).toString(16).padStart(2, '0')}${Math.max(0, b).toString(16).padStart(2, '0')}`;
  }
}

// Exemplo de uso
document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('layoutCanvas');
  canvas.width = 800;
  canvas.height = 600;
  
  const controller = new LayoutController(canvas);
  
  // Layout 1: Barra superior (horizontal, ocupa toda largura, altura fixa de 50px)
  const topBarLayout = controller.addLayout(new Layout({
    direction: 'vertical',
    fixedSize: 50,
    color: '#ecf0f1'
  }));
  
  // Adicionar botões à barra superior
  topBarLayout.addWidget(new Button({
    x: 10,
    y: 10,
    width: 100,
    height: 30,
    text: 'Menu',
    color: '#3498db'
  }));
  
  topBarLayout.addWidget(new Button({
    x: 120,
    y: 10,
    width: 100,
    height: 30,
    text: 'Opções',
    color: '#3498db'
  }));
  
  // Layout 2: Sidebar esquerda (vertical, 20% da largura restante)
  const leftSidebarLayout = controller.addLayout(new Layout({
    direction: 'horizontal',
    percentage: 20,
    color: '#d6eaf8'
  }));
  
  leftSidebarLayout.addWidget(new Button({
    x: 10,
    y: 20,
    width: 120,
    height: 40,
    text: 'Opção 1',
    color: '#2980b9'
  }));
  
  leftSidebarLayout.addWidget(new Button({
    x: 10,
    y: 70,
    width: 120,
    height: 40,
    text: 'Opção 2',
    color: '#2980b9'
  }));
  
  // Layout 3: Área principal (vertical, ocupa o restante do espaço)
  const mainContentLayout = controller.addLayout(new Layout({
    direction: 'horizontal',
    percentage: 80,
    color: '#ffffff'
  }));
  
  mainContentLayout.addWidget(new Widget({
    x: 20,
    y: 20,
    width: 400,
    height: 300,
    text: 'Área de Conteúdo Principal',
    color: '#e8f8f5'
  }));
  
  // Renderizar o layout
  controller.render();
  
  // Adicionar interação de mouse
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    let needsRender = false;
    
    controller.layouts.forEach(layout => {
      layout.widgets.forEach(widget => {
        if (widget instanceof Button) {
          const absoluteX = layout.x + widget.x;
          const absoluteY = layout.y + widget.y;
          
          const wasHovered = widget.hovered;
          widget.hovered = mouseX >= absoluteX && 
                           mouseX <= absoluteX + widget.width && 
                           mouseY >= absoluteY && 
                           mouseY <= absoluteY + widget.height;
          
          if (wasHovered !== widget.hovered) {
            needsRender = true;
          }
        }
      });
    });
    
    if (needsRender) {
      controller.render();
    }
  });
  
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    controller.layouts.forEach(layout => {
      layout.widgets.forEach(widget => {
        if (widget instanceof Button) {
          const absoluteX = layout.x + widget.x;
          const absoluteY = layout.y + widget.y;
          
          if (mouseX >= absoluteX && 
              mouseX <= absoluteX + widget.width && 
              mouseY >= absoluteY && 
              mouseY <= absoluteY + widget.height) {
            widget.onClick();
            console.log(`Botão "${widget.text}" clicado!`);
          }
        }
      });
    });
  });
});

    </script>
</body>
</html>