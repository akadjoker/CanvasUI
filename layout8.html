<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Responsivo com Layouts</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        // Configuração inicial do canvas para ocupar toda a tela
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Função para ajustar o tamanho do canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Se o sistema UI já estiver inicializado, atualizar layouts
            if (window.uiSystem) {
                // Atualizar o tamanho do layout principal
                window.mainLayout.width = canvas.width - 20;
                window.mainLayout.height = canvas.height - 20;
                
                // Atualizar posições e tamanhos de todos os componentes
                window.mainLayout.updateLayout();
                
                // Renderizar novamente
                window.uiSystem.render();
            }
        }
        
        // Classe base para componentes UI
        class UIComponent {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.visible = true;
            }
            
            contains(x, y) {
                return (
                    x >= this.x && 
                    x <= this.x + this.width && 
                    y >= this.y && 
                    y <= this.y + this.height
                );
            }
            
            render(ctx) {
                // Para ser implementado pelas subclasses
            }
        }
        
        // Classe para botões
        class Button extends UIComponent {
            constructor(x, y, width, height, text, onClick) {
                super(x, y, width, height);
                this.text = text;
                this.onClick = onClick;
                this.hovered = false;
                this.pressed = false;
                this.bgColor = '#3498db';
                this.hoverColor = '#2980b9';
                this.pressColor = '#1c5c85';
                this.textColor = '#ffffff';
            }
            
            render(ctx) {
                if (!this.visible) return;
                
                // Determinar cor de fundo baseado no estado
                let bgColor = this.bgColor;
                if (this.pressed) {
                    bgColor = this.pressColor;
                } else if (this.hovered) {
                    bgColor = this.hoverColor;
                }
                
                // Desenhar fundo do botão
                ctx.fillStyle = bgColor;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, 4);
                ctx.fill();
                
                // Desenhar borda
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Desenhar texto
                ctx.fillStyle = this.textColor;
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);
            }
        }
        
        // Classe para layout horizontal
        class HorizontalLayout extends UIComponent {
            constructor(x, y, width, height) {
                super(x, y, width, height);
                this.children = [];
                this.percentages = [];
                this.padding = 5;
            }
            
            addChild(component, percentage) {
                this.children.push(component);
                this.percentages.push(percentage);
                this.updateLayout();
            }
            
            updateLayout() {
                // Verificar se as porcentagens somam 100%
                const totalPercentage = this.percentages.reduce((sum, p) => sum + p, 0);
                if (totalPercentage > 0) {
                    // Normalizar percentagens se necessário
                    const factor = 100 / totalPercentage;
                    if (factor !== 1) {
                        this.percentages = this.percentages.map(p => p * factor);
                    }
                }
                
                // Calcular e definir posição e tamanho dos filhos
                let currentX = this.x + this.padding;
                const availableWidth = this.width - (this.padding * 2);
                
                for (let i = 0; i < this.children.length; i++) {
                    const childWidth = (availableWidth * this.percentages[i] / 100) - (this.padding * (this.children.length - 1) / this.children.length);
                    const child = this.children[i];
                    
                    child.x = currentX;
                    child.y = this.y + this.padding;
                    child.width = childWidth;
                    child.height = this.height - (this.padding * 2);
                    
                    currentX += childWidth + this.padding;
                    
                    // Se o filho for um layout, atualizar recursivamente
                    if (child instanceof HorizontalLayout || child instanceof VerticalLayout) {
                        child.updateLayout();
                    }
                }
            }
            
            render(ctx) {
                if (!this.visible) return;
                
                // Desenhar fundo do layout (opcional)
                ctx.fillStyle = 'rgba(240, 240, 240, 0.5)';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Renderizar cada filho
                for (const child of this.children) {
                    child.render(ctx);
                }
            }
            
            contains(x, y) {
                if (!super.contains(x, y)) return false;
                
                // Verificar se algum filho contém o ponto
                for (const child of this.children) {
                    if (child.contains(x, y)) {
                        return true;
                    }
                }
                
                return true;
            }
        }
        
        // Classe para layout vertical
        class VerticalLayout extends UIComponent {
            constructor(x, y, width, height) {
                super(x, y, width, height);
                this.children = [];
                this.percentages = [];
                this.padding = 5;
            }
            
            addChild(component, percentage) {
                this.children.push(component);
                this.percentages.push(percentage);
                this.updateLayout();
            }
            
            updateLayout() {
                // Verificar se as porcentagens somam 100%
                const totalPercentage = this.percentages.reduce((sum, p) => sum + p, 0);
                if (totalPercentage > 0) {
                    // Normalizar percentagens se necessário
                    const factor = 100 / totalPercentage;
                    if (factor !== 1) {
                        this.percentages = this.percentages.map(p => p * factor);
                    }
                }
                
                // Calcular e definir posição e tamanho dos filhos
                let currentY = this.y + this.padding;
                const availableHeight = this.height - (this.padding * 2);
                
                for (let i = 0; i < this.children.length; i++) {
                    const childHeight = (availableHeight * this.percentages[i] / 100) - (this.padding * (this.children.length - 1) / this.children.length);
                    const child = this.children[i];
                    
                    child.x = this.x + this.padding;
                    child.y = currentY;
                    child.width = this.width - (this.padding * 2);
                    child.height = childHeight;
                    
                    currentY += childHeight + this.padding;
                    
                    // Se o filho for um layout, atualizar recursivamente
                    if (child instanceof HorizontalLayout || child instanceof VerticalLayout) {
                        child.updateLayout();
                    }
                }
            }
            
            render(ctx) {
                if (!this.visible) return;
                
                // Desenhar fundo do layout (opcional)
                ctx.fillStyle = 'rgba(240, 240, 240, 0.5)';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Renderizar cada filho
                for (const child of this.children) {
                    child.render(ctx);
                }
            }
            
            contains(x, y) {
                if (!super.contains(x, y)) return false;
                
                // Verificar se algum filho contém o ponto
                for (const child of this.children) {
                    if (child.contains(x, y)) {
                        return true;
                    }
                }
                
                return true;
            }
        }
        
        // Sistema para gerenciar componentes e eventos
        class UISystem {
            constructor(canvas) {
                this.canvas = canvas;
                this.components = [];
                this.hoverComponent = null;
                this.activeComponent = null;
                
                // Configurar handlers de eventos
                this.setupEvents();
            }
            
            addComponent(component) {
                this.components.push(component);
                return component;
            }
            
            setupEvents() {
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
            }
            
            // Converter coordenadas de toque para coordenadas do canvas
            getTouchPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const touch = e.touches[0] || e.changedTouches[0];
                return {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                const pos = this.getTouchPos(e);
                this.handleMouseDown({clientX: pos.x, clientY: pos.y});
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                const pos = this.getTouchPos(e);
                this.handleMouseUp({clientX: pos.x, clientY: pos.y});
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                const pos = this.getTouchPos(e);
                this.handleMouseMove({clientX: pos.x, clientY: pos.y});
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                let found = false;
                
                // Resetar estado hover dos botões
                for (const component of this.components) {
                    if (component instanceof Button) {
                        if (component.contains(x, y)) {
                            component.hovered = true;
                            found = true;
                            this.hoverComponent = component;
                        } else {
                            component.hovered = false;
                        }
                    }
                }
                
                if (!found) {
                    this.hoverComponent = null;
                }
                
                this.render();
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                for (const component of this.components) {
                    if (component instanceof Button && component.contains(x, y)) {
                        component.pressed = true;
                        this.activeComponent = component;
                        break;
                    }
                }
                
                this.render();
            }
            
            handleMouseUp(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.activeComponent && this.activeComponent instanceof Button) {
                    if (this.activeComponent.contains(x, y) && this.activeComponent.onClick) {
                        this.activeComponent.onClick();
                    }
                    this.activeComponent.pressed = false;
                    this.activeComponent = null;
                }
                
                this.render();
            }
            
            render() {
                // Limpar canvas
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Renderizar todos os componentes
                for (const component of this.components) {
                    component.render(ctx);
                }
            }
        }
        
        // Função de inicialização
        function init() {
            // Ajustar o tamanho do canvas
            resizeCanvas();
            
            // Inicializar sistema UI
            window.uiSystem = new UISystem(canvas);
            
            // Criar um layout vertical principal
            window.mainLayout = new VerticalLayout(10, 10, canvas.width - 20, canvas.height - 20);
            uiSystem.addComponent(window.mainLayout);
            
            // Criar um layout horizontal no topo (ocupando a primeira 15%)
            const topLayout = new HorizontalLayout(0, 0, 0, 0);
            window.mainLayout.addChild(topLayout, 15);
            
            // Criar um layout horizontal embaixo (ocupando 85%)
            const bottomLayout = new HorizontalLayout(0, 0, 0, 0);
            window.mainLayout.addChild(bottomLayout, 85);
            
            // Adicionar botões ao layout superior
            topLayout.addChild(new Button(0, 0, 0, 0, "Home", () => {
                alert("Home selecionado!");
            }), 20);
            
            topLayout.addChild(new Button(0, 0, 0, 0, "Produtos", () => {
                alert("Produtos selecionado!");
            }), 20);
            
            topLayout.addChild(new Button(0, 0, 0, 0, "Serviços", () => {
                alert("Serviços selecionado!");
            }), 20);
            
            topLayout.addChild(new Button(0, 0, 0, 0, "Contato", () => {
                alert("Contato selecionado!");
            }), 20);
            
            topLayout.addChild(new Button(0, 0, 0, 0, "Sobre", () => {
                alert("Sobre selecionado!");
            }), 20);
            
            // Adicionar um layout vertical à esquerda (ocupando 20% do layout inferior)
            const leftLayout = new VerticalLayout(0, 0, 0, 0);
            bottomLayout.addChild(leftLayout, 20);
            
            // Adicionar um layout vertical à direita (ocupando 80% do layout inferior)
            const rightLayout = new VerticalLayout(0, 0, 0, 0);
            bottomLayout.addChild(rightLayout, 80);
            
            // Adicionar botões ao layout esquerdo
            leftLayout.addChild(new Button(0, 0, 0, 0, "Dashboard", () => {
                alert("Dashboard selecionado");
            }), 20);
            
            leftLayout.addChild(new Button(0, 0, 0, 0, "Relatórios", () => {
                alert("Relatórios selecionado");
            }), 20);
            
            leftLayout.addChild(new Button(0, 0, 0, 0, "Configurações", () => {
                alert("Configurações selecionado");
            }), 20);
            
            leftLayout.addChild(new Button(0, 0, 0, 0, "Usuários", () => {
                alert("Usuários selecionado");
            }), 20);
            
            leftLayout.addChild(new Button(0, 0, 0, 0, "Ajuda", () => {
                alert("Ajuda selecionada");
            }), 20);
            
            // Adicionar conteúdo ao layout direito
            // (dividido em duas seções, uma com 80% e outra com 20%)
            const contentTop = new VerticalLayout(0, 0, 0, 0);
            rightLayout.addChild(contentTop, 80);
            
            const contentBottom = new HorizontalLayout(0, 0, 0, 0);
            rightLayout.addChild(contentBottom, 20);
            
            // Botões na parte inferior direita
            contentBottom.addChild(new Button(0, 0, 0, 0, "Salvar", () => {
                alert("Alterações salvas");
            }), 25);
            
            contentBottom.addChild(new Button(0, 0, 0, 0, "Cancelar", () => {
                alert("Operação cancelada");
            }), 25);
            
            contentBottom.addChild(new Button(0, 0, 0, 0, "Imprimir", () => {
                alert("Enviando para impressão");
            }), 25);
            
            contentBottom.addChild(new Button(0, 0, 0, 0, "Exportar", () => {
                alert("Exportando dados");
            }), 25);
            
            // Adicionar algum conteúdo à área principal
            const centerArea = new VerticalLayout(0, 0, 0, 0);
            contentTop.addChild(centerArea, 100);
            
            // Adicionar uma grade de botões à área central
            for (let row = 0; row < 3; row++) {
                const rowLayout = new HorizontalLayout(0, 0, 0, 0);
                centerArea.addChild(rowLayout, 33.33);
                
                for (let col = 0; col < 4; col++) {
                    rowLayout.addChild(new Button(0, 0, 0, 0, `Item ${row*4 + col + 1}`, () => {
                        alert(`Item ${row*4 + col + 1} selecionado`);
                    }), 25);
                }
            }
            
            // Atualizar layout e renderizar
            window.mainLayout.updateLayout();
            window.uiSystem.render();
        }
        
        // Evento de redimensionamento da janela
        window.addEventListener('resize', resizeCanvas);
        
        // Inicializar quando o documento estiver carregado
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>