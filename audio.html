<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Widgets de Áudio</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .widget-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }
        .widget {
            background-color: #fff;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 150px;
        }
        .widget-title {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
        .widget-value {
            margin-top: 5px;
            font-size: 12px;
            color: #999;
        }
        .controls {
            margin-top: 30px;
            text-align: center;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Widgets de Áudio com Canvas</h1>
    
    <div class="widget-container">

    </div>
    
    <div class="controls">
        <button id="playButton">Tocar Som</button>
    </div>

    <script>

        class Widget {
            constructor(container, title, minValue = 0, maxValue = 100, defaultValue = 50) {
                this.minValue = minValue;
                this.maxValue = maxValue;
                this.value = defaultValue;
                this.title = title;
                this.isDragging = false;
                
                // Criar elemento do widget
                this.element = document.createElement('div');
                this.element.className = 'widget';
                
                // Criar canvas
                this.canvas = document.createElement('canvas');
                this.canvas.width = 120;
                this.canvas.height = 120;
                this.ctx = this.canvas.getContext('2d');
                
                // Título e valor
                this.titleElement = document.createElement('div');
                this.titleElement.className = 'widget-title';
                this.titleElement.textContent = title;
                
                this.valueElement = document.createElement('div');
                this.valueElement.className = 'widget-value';
                this.valueElement.textContent = defaultValue;
                
                // Adicionar elementos ao widget
                this.element.appendChild(this.canvas);
                this.element.appendChild(this.titleElement);
                this.element.appendChild(this.valueElement);
                
                // Adicionar widget ao container
                container.appendChild(this.element);
                
                // Event listeners
                this.setupEventListeners();
                
                // Renderizar inicialmente
                this.render();
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                // Suporte para touch
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleMouseDown(this.getTouchPosition(e));
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (this.isDragging) {
                        e.preventDefault();
                        this.handleMouseMove(this.getTouchPosition(e));
                    }
                });
                
                document.addEventListener('touchend', () => {
                    this.handleMouseUp();
                });
            }
            
            getTouchPosition(touchEvent) {
                if (touchEvent.touches.length > 0) {
                    const touch = touchEvent.touches[0];
                    return {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    };
                }
                return null;
            }
            
            handleMouseDown(e) {
                this.isDragging = true;
                this.updateValueFromEvent(e);
            }
            
            handleMouseMove(e) {
                if (this.isDragging) {
                    this.updateValueFromEvent(e);
                }
            }
            
            handleMouseUp() {
                this.isDragging = false;
            }
            
            updateValueFromEvent(e) {
                // Implementado pelas subclasses
            }
            
            setValue(newValue) {
                // Limitar valor entre min e max
                this.value = Math.max(this.minValue, Math.min(this.maxValue, newValue));
                this.valueElement.textContent = Math.round(this.value);
                this.render();
                return this.value;
            }
            
            getValue() {
                return this.value;
            }
            
            getNormalizedValue() {
                return (this.value - this.minValue) / (this.maxValue - this.minValue);
            }
            
            render() {
                // Implementado pelas subclasses
            }
        }
        
        // Classe para Knob (botão giratório)
        class Knob extends Widget {
            constructor(container, title, minValue = 0, maxValue = 100, defaultValue = 50) {
                super(container, title, minValue, maxValue, defaultValue);
            }
            
            updateValueFromEvent(e) {
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const x = e.clientX - rect.left - centerX;
                const y = e.clientY - rect.top - centerY;
                
                // Calcular ângulo
                let angle = Math.atan2(y, x) + Math.PI / 2;
                if (angle < 0) angle += Math.PI * 2;
                
                // Limitar a 270 graus (de 135 a 405 graus, normalizado para 0-1)
                const startAngle = Math.PI * 0.75; // 135 graus
                const endAngle = Math.PI * 2.25; // 405 graus
                const angleRange = endAngle - startAngle;
                
                // Ajustar ângulo para a faixa desejada
                if (angle < startAngle || angle > endAngle) {
                    if (angle > endAngle) angle = endAngle;
                    else angle = startAngle;
                }
                
                // Converter ângulo para valor
                const normalized = (angle - startAngle) / angleRange;
                const newValue = this.minValue + normalized * (this.maxValue - this.minValue);
                
                this.setValue(newValue);
            }
            
            render() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) / 2 - 10;
                
                // Limpar canvas
                ctx.clearRect(0, 0, width, height);
                
                // Desenhar círculo base
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = '#e0e0e0';
                ctx.fill();
                
                // Desenhar arco de progresso
                const startAngle = Math.PI * 0.75; // 135 graus
                const endAngle = startAngle + (Math.PI * 1.5) * this.getNormalizedValue(); // 270 graus máximo
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.lineWidth = 10;
                ctx.strokeStyle = '#4CAF50';
                ctx.stroke();
                
                // Desenhar linhas de marcação
                for (let i = 0; i <= 10; i++) {
                    const angle = startAngle + (Math.PI * 1.5) * (i / 10);
                    const innerRadius = radius - 5;
                    const outerRadius = i % 5 === 0 ? radius + 5 : radius + 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        centerX + innerRadius * Math.cos(angle),
                        centerY + innerRadius * Math.sin(angle)
                    );
                    ctx.lineTo(
                        centerX + outerRadius * Math.cos(angle),
                        centerY + outerRadius * Math.sin(angle)
                    );
                    ctx.lineWidth = i % 5 === 0 ? 2 : 1;
                    ctx.strokeStyle = '#666';
                    ctx.stroke();
                }
                
                // Desenhar indicador
                const indicatorAngle = startAngle + (Math.PI * 1.5) * this.getNormalizedValue();
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + (radius - 5) * Math.cos(indicatorAngle),
                    centerY + (radius - 5) * Math.sin(indicatorAngle)
                );
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#333';
                ctx.stroke();
                
                // Desenhar círculo central
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius / 6, 0, Math.PI * 2);
                ctx.fillStyle = '#333';
                ctx.fill();
            }
        }
        
        // Classe para Slider
        class Slider extends Widget {
            constructor(container, title, minValue = 0, maxValue = 100, defaultValue = 50, vertical = false) {
                super(container, title, minValue, maxValue, defaultValue);
                this.vertical = vertical;
                
                // Ajustar dimensões para slider vertical
                if (vertical) {
                    this.canvas.width = 60;
                    this.canvas.height = 120;
                } else {
                    this.canvas.width = 120;
                    this.canvas.height = 60;
                }
            }
            
            updateValueFromEvent(e) {
                const rect = this.canvas.getBoundingClientRect();
                
                if (this.vertical) {
                    const heightRange = rect.height - 20; // Espaço para os extremos
                    const relativeY = e.clientY - rect.top - 10;
                    const normalized = 1 - (relativeY / heightRange);
                    const newValue = this.minValue + normalized * (this.maxValue - this.minValue);
                    this.setValue(newValue);
                } else {
                    const widthRange = rect.width - 20; // Espaço para os extremos
                    const relativeX = e.clientX - rect.left - 10;
                    const normalized = relativeX / widthRange;
                    const newValue = this.minValue + normalized * (this.maxValue - this.minValue);
                    this.setValue(newValue);
                }
            }
            
            render() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Limpar canvas
                ctx.clearRect(0, 0, width, height);
                
                if (this.vertical) {
                    // Desenhar trilho vertical
                    const sliderX = width / 2;
                    const startY = 10;
                    const endY = height - 10;
                    
                    // Trilho base
                    ctx.beginPath();
                    ctx.moveTo(sliderX, startY);
                    ctx.lineTo(sliderX, endY);
                    ctx.lineWidth = 6;
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.stroke();
                    
                    // Trilho de progresso
                    const progressY = endY - ((endY - startY) * this.getNormalizedValue());
                    
                    ctx.beginPath();
                    ctx.moveTo(sliderX, endY);
                    ctx.lineTo(sliderX, progressY);
                    ctx.lineWidth = 6;
                    ctx.strokeStyle = '#4CAF50';
                    ctx.stroke();
                    
                    // Manípulo
                    ctx.beginPath();
                    ctx.arc(sliderX, progressY, 10, 0, Math.PI * 2);
                    ctx.fillStyle = '#333';
                    ctx.fill();
                    
                    // Marcações
                    for (let i = 0; i <= 5; i++) {
                        const markY = startY + (endY - startY) * (1 - i / 5);
                        ctx.beginPath();
                        ctx.moveTo(sliderX - 10, markY);
                        ctx.lineTo(sliderX + 10, markY);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = '#666';
                        ctx.stroke();
                    }
                } else {
                    // Desenhar trilho horizontal
                    const sliderY = height / 2;
                    const startX = 10;
                    const endX = width - 10;
                    
                    // Trilho base
                    ctx.beginPath();
                    ctx.moveTo(startX, sliderY);
                    ctx.lineTo(endX, sliderY);
                    ctx.lineWidth = 6;
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.stroke();
                    
                    // Trilho de progresso
                    const progressX = startX + ((endX - startX) * this.getNormalizedValue());
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, sliderY);
                    ctx.lineTo(progressX, sliderY);
                    ctx.lineWidth = 6;
                    ctx.strokeStyle = '#4CAF50';
                    ctx.stroke();
                    
                    // Manípulo
                    ctx.beginPath();
                    ctx.arc(progressX, sliderY, 10, 0, Math.PI * 2);
                    ctx.fillStyle = '#333';
                    ctx.fill();
                    
                    // Marcações
                    for (let i = 0; i <= 5; i++) {
                        const markX = startX + (endX - startX) * (i / 5);
                        ctx.beginPath();
                        ctx.moveTo(markX, sliderY - 10);
                        ctx.lineTo(markX, sliderY + 10);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = '#666';
                        ctx.stroke();
                    }
                }
            }
        }
        
        // Classe para visualizador XY (como um pad)
        class XYPad extends Widget {
            constructor(container, title, minValue = 0, maxValue = 100, defaultX = 50, defaultY = 50) {
                super(container, title, minValue, maxValue, defaultX);
                this.valueY = defaultY;
                
                // Sobrescrever o elemento de valor para mostrar X e Y
                this.valueElement.textContent = `X: ${defaultX}, Y: ${defaultY}`;
            }
            
            updateValueFromEvent(e) {
                const rect = this.canvas.getBoundingClientRect();
                const size = rect.width; // Assumindo que é quadrado
                
                const relativeX = e.clientX - rect.left;
                const relativeY = e.clientY - rect.top;
                
                const normalizedX = relativeX / size;
                const normalizedY = relativeY / size;
                
                this.setValue(this.minValue + normalizedX * (this.maxValue - this.minValue));
                this.setValueY(this.minValue + (1 - normalizedY) * (this.maxValue - this.minValue));
            }
            
            setValueY(newValue) {
                this.valueY = Math.max(this.minValue, Math.min(this.maxValue, newValue));
                this.valueElement.textContent = `X: ${Math.round(this.value)}, Y: ${Math.round(this.valueY)}`;
                this.render();
                return this.valueY;
            }
            
            getNormalizedValueY() {
                return (this.valueY - this.minValue) / (this.maxValue - this.minValue);
            }
            
            render() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Limpar canvas
                ctx.clearRect(0, 0, width, height);
                
                // Desenhar fundo
                ctx.fillStyle = '#e0e0e0';
                ctx.fillRect(0, 0, width, height);
                
                // Desenhar grade
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= 10; i++) {
                    const pos = width * (i / 10);
                    
                    // Linhas verticais
                    ctx.beginPath();
                    ctx.moveTo(pos, 0);
                    ctx.lineTo(pos, height);
                    ctx.stroke();
                    
                    // Linhas horizontais
                    ctx.beginPath();
                    ctx.moveTo(0, pos);
                    ctx.lineTo(width, pos);
                    ctx.stroke();
                }
                
                // Calcular posição do cursor
                const xPos = width * this.getNormalizedValue();
                const yPos = height * (1 - this.getNormalizedValueY());
                
                // Desenhar linhas de posição
                ctx.strokeStyle = 'rgba(74, 175, 80, 0.5)';
                ctx.lineWidth = 2;
                
                // Linha vertical
                ctx.beginPath();
                ctx.moveTo(xPos, 0);
                ctx.lineTo(xPos, height);
                ctx.stroke();
                
                // Linha horizontal
                ctx.beginPath();
                ctx.moveTo(0, yPos);
                ctx.lineTo(width, yPos);
                ctx.stroke();
                
                // Desenhar cursor
                ctx.beginPath();
                ctx.arc(xPos, yPos, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#4CAF50';
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#333';
                ctx.stroke();
            }
        }

        // Configurar contexto de áudio
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioContext = new AudioContext();
        
        // Oscilador
        let oscillator = null;
        let gainNode = null;
        
        // Função para iniciar ou parar o som
        function toggleSound() {
            if (oscillator === null) {
                // Iniciar som
                oscillator = audioContext.createOscillator();
                gainNode = audioContext.createGain();
                
                // Configurar tipo e frequência
                oscillator.type = waveTypeKnob.getValue() < 25 ? 'sine' : 
                                waveTypeKnob.getValue() < 50 ? 'square' : 
                                waveTypeKnob.getValue() < 75 ? 'sawtooth' : 'triangle';
                
                oscillator.frequency.value = frequencyKnob.getValue();
                gainNode.gain.value = volumeSlider.getValue() / 100;
                
                // Conectar nós
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Iniciar oscilador
                oscillator.start();
                playButton.textContent = "Parar Som";
            } else {
                // Parar som
                oscillator.stop();
                oscillator = null;
                gainNode = null;
                playButton.textContent = "Tocar Som";
            }
        }
        
        // Contêiner de widgets
        const container = document.querySelector('.widget-container');
        
        // Criar widgets
        const frequencyKnob = new Knob(container, "Frequência (Hz)", 100, 2000, 440);
        const waveTypeKnob = new Knob(container, "Tipo de Onda", 0, 100, 0);
        const volumeSlider = new Slider(container, "Volume", 0, 100, 50);
        const filterSlider = new Slider(container, "Filtro", 0, 100, 50, true);
        const xyPad = new XYPad(container, "Modulação X/Y", 0, 100, 50, 50);
        
        // Configurar eventos
        const playButton = document.getElementById('playButton');
        playButton.addEventListener('click', toggleSound);
        
        // Atualizar oscilador quando os widgets mudam
        frequencyKnob.canvas.addEventListener('mouseup', () => {
            if (oscillator) oscillator.frequency.value = frequencyKnob.getValue();
        });
        
        waveTypeKnob.canvas.addEventListener('mouseup', () => {
            if (oscillator) {
                oscillator.type = waveTypeKnob.getValue() < 25 ? 'sine' : 
                                waveTypeKnob.getValue() < 50 ? 'square' : 
                                waveTypeKnob.getValue() < 75 ? 'sawtooth' : 'triangle';
            }
        });
        
        volumeSlider.canvas.addEventListener('mouseup', () => {
            if (gainNode) gainNode.gain.value = volumeSlider.getValue() / 100;
        });
    </script>
</body>
</html>