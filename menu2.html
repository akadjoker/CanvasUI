<!DOCTYPE html>
<html>
<head>
    <title>Sistema de Menus Portável</title>
    <style>
        body { margin: 0; }
        canvas { display: block; background: #f0f0f0; }
    </style>
</head>
<body>
    <canvas id="menuCanvas" width="800" height="600"></canvas>
    <script>

        // Classe base para itens de menu
class MenuItem {
    constructor(text, action = null, submenu = null) {
        this.text = text;
        this.action = action;
        this.submenu = submenu;
        this.bounds = { x: 0, y: 0, width: 0, height: 0 };
        this.isHovered = false;
    }

    contains(x, y) {
        return x >= this.bounds.x && 
               x <= this.bounds.x + this.bounds.width &&
               y >= this.bounds.y && 
               y <= this.bounds.y + this.bounds.height;
    }

    execute() {
        if (this.action) {
            this.action();
            return true;
        }
        return false;
    }
}

// Classe para representar um menu completo
class Menu {
    constructor(title, x, y) {
        this.title = title;
        this.x = x;
        this.y = y;
        this.items = [];
        this.width = 0;
        this.height = 0;
        this.itemHeight = 25;
        this.padding = 5;
        this.isVisible = false;
        this.parentMenu = null;
    }

    addItem(text, action = null, submenu = null) {
        const item = new MenuItem(text, action, submenu);
        this.items.push(item);
        if (submenu) {
            submenu.parentMenu = this;
        }
        return item;
    }

    calculateDimensions(ctx) {
        ctx.font = '14px Arial';
        this.width = ctx.measureText(this.title).width + 20;
        
        for (const item of this.items) {
            const textWidth = ctx.measureText(item.text + (item.submenu ? " ▶" : "")).width + 20;
            this.width = Math.max(this.width, textWidth);
        }
        
        this.height = this.items.length * this.itemHeight + 2 * this.padding;
    }

    updateBounds() {
        let currentY = this.y + this.padding;
        
        for (const item of this.items) {
            item.bounds = {
                x: this.x,
                y: currentY,
                width: this.width,
                height: this.itemHeight
            };
            currentY += this.itemHeight;
            
            if (item.submenu && item.isHovered) {
                item.submenu.x = this.x + this.width;
                item.submenu.y = item.bounds.y;
                item.submenu.updateBounds();
            }
        }
    }

    draw(ctx) {
        if (!this.isVisible) return;
        
        // Fundo do menu
        ctx.fillStyle = '#333';
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Borda do menu
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        
        // Itens do menu
        ctx.font = '14px Arial';
        ctx.textBaseline = 'middle';
        
        for (const item of this.items) {
            // Fundo do item
            ctx.fillStyle = item.isHovered ? '#555' : '#333';
            ctx.fillRect(item.bounds.x, item.bounds.y, item.bounds.width, item.bounds.height);
            
            // Texto do item
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'left';
            const text = item.text + (item.submenu ? " ▶" : "");
            ctx.fillText(text, item.bounds.x + 5, item.bounds.y + item.bounds.height / 2);
            
            // Desenha submenu se hovered
            if (item.submenu && item.isHovered) {
                item.submenu.draw(ctx);
            }
        }
    }

    handleMouseMove(x, y) {
        if (!this.isVisible) return null;
        
        let handled = false;
        
        for (const item of this.items) {
            const wasHovered = item.isHovered;
            item.isHovered = item.contains(x, y);
            
            if (item.isHovered && !wasHovered && item.submenu) {
                item.submenu.isVisible = true;
                this.hideOtherSubmenus(item);
            }
            
            if (item.isHovered) {
                handled = true;
            }
            
            if (item.submenu) {
                handled = item.submenu.handleMouseMove(x, y) || handled;
            }
        }
        
        return handled;
    }

    hideOtherSubmenus(exceptItem = null) {
        for (const item of this.items) {
            if (item !== exceptItem && item.submenu) {
                item.submenu.isVisible = false;
                item.submenu.hideOtherSubmenus();
            }
        }
    }

    handleMouseDown(x, y) {
        if (!this.isVisible) return false;
        
        for (const item of this.items) {
            if (item.contains(x, y)) {
                if (item.submenu) {
                    item.submenu.isVisible = true;
                    this.hideOtherSubmenus(item);
                    return true;
                } else if (item.execute()) {
                    this.hideAllMenus();
                    return true;
                }
            }
            
            if (item.submenu && item.submenu.handleMouseDown(x, y)) {
                return true;
            }
        }
        
        return false;
    }

    hideAllMenus() {
        this.isVisible = false;
        for (const item of this.items) {
            if (item.submenu) {
                item.submenu.hideAllMenus();
            }
        }
        
        if (this.parentMenu) {
            this.parentMenu.hideAllMenus();
        }
    }
}

// Sistema principal para gerenciar os menus
class MenuManager {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.menus = [];
        this.rootMenu = null;
        
        // Configura eventos
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        
        // Inicia o loop de renderização
        this.render();
    }
    
    createMenu(title, x, y) {
        const menu = new Menu(title, x, y);
        this.menus.push(menu);
        
        if (!this.rootMenu) {
            this.rootMenu = menu;
        }
        
        return menu;
    }
    
    handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (this.rootMenu) {
            const handled = this.rootMenu.handleMouseMove(x, y);
            if (!handled) {
                this.rootMenu.hideOtherSubmenus();
            }
        }
    }
    
    handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (this.rootMenu) {
            if (!this.rootMenu.handleMouseDown(x, y)) {
                // Clicou fora do menu
                if (this.rootMenu.isVisible) {
                    this.rootMenu.hideAllMenus();
                } else {
                    this.rootMenu.isVisible = true;
                    this.rootMenu.calculateDimensions(this.ctx);
                    this.rootMenu.updateBounds();
                }
            }
        }
    }
    
    render() {
        // Limpa o canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Desenha todos os menus
        if (this.rootMenu) {
            this.rootMenu.draw(this.ctx);
        }
        
        // Continua o loop
        requestAnimationFrame(() => this.render());
    }
}

// Exemplo de uso
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('menuCanvas');
    const menuManager = new MenuManager(canvas);
    
    // Cria menu principal
    const mainMenu = menuManager.createMenu('Menu Principal', 20, 20);
    
    // Adiciona itens com submenus
    const fileMenu = menuManager.createMenu('Arquivo', 0, 0);
    fileMenu.addItem('Abrir', () => console.log('Abrir arquivo'));
    fileMenu.addItem('Salvar', () => console.log('Salvar arquivo'));
    fileMenu.addItem('Sair', () => console.log('Sair'));
    
    const editMenu = menuManager.createMenu('Editar', 0, 0);
    editMenu.addItem('Copiar', () => console.log('Copiar'));
    editMenu.addItem('Colar', () => console.log('Colar'));
    
    const viewMenu = menuManager.createMenu('Visualizar', 0, 0);
    viewMenu.addItem('Zoom In', () => console.log('Zoom In'));
    viewMenu.addItem('Zoom Out', () => console.log('Zoom Out'));
    
    // Adiciona ao menu principal
    mainMenu.addItem('Arquivo', null, fileMenu);
    mainMenu.addItem('Editar', null, editMenu);
    mainMenu.addItem('Visualizar', null, viewMenu);
    mainMenu.addItem('Ajuda', () => console.log('Mostrar ajuda'));
    
    // Calcula dimensões iniciais
    mainMenu.calculateDimensions(menuManager.ctx);
    mainMenu.updateBounds();
});
    </script>
</body>
</html>